一个在def内定义的变量名能够被def内的代码使用。不能在函数的外部引用这样的变量名
def之中的变量名与def之外的变量名并不冲突，即使是使用在别处相同的变量名。一个在def之外被赋值的变量X与在这个def之中的赋值变量x是完全不同的变量

函数定义了本地作用域，而模块定义的是全局作用域。这两个作用域的关系如下：
1，内嵌的模块是全局作用域
2，全局作用域的作用范围仅限于单个文件
3，每次对函数的调用都创建了一个新的本地作用域（递归在处理不能提前预知的流程结构时是一个有用的工具）
4，赋值的变量名除非声明为全局变量或非本地变量，否则均为本地变量
5，所有其他的变量名都可以归纳为本地、全局或者内置的
修改一个对象并不是对一个名称赋值

变量名解析：
a>变量名引用分为三个作用域进行查找：首先是本地，之后是函数内（如果有的话），之后全局，最后是内置
b>默认情况下，变量名赋值会创建或者改变本地变量。
c>全局声明和非本地声明将赋值的变量名映射到模块文件内部的作用域

内置作用域仅仅是一个名为_builtin_的内置模块，但是必须要import_buildin_之后才能使用内置作用域，因为变量名builtin本身并没有预先内置

global是一个命名空间的声明，它告诉Python函数打算生成一个或多个全局变量名。

全局变量名总结：
1，全局变量是位于模块文件内部的顶层的变量名
2，全局变量如果是在函数内被赋值的话，必须经过声明
3，全局变量名在函数的内部不经过声明也可以被引用

在文件间进行通信的最好办法就是通过调用函数，传递函数，然后得到其返回值。

工厂函数，一个能够记住嵌套作用域的变量值的函数，尽管那个作用域已经不存在了。
 
 如果lambda或者def在函数中定义，嵌套在一个循环之中，并且嵌套的函数引用了一个上层作用域变量，该变量被循环所改变，所有在这个循环中产生的函数将会有相同的值--在最后一次循环中完成时被引用的变量的值

 nonlocal和global一样，声明了将要在一个嵌套的作用域中修改的名称。和global的不同之处在于，nonlocal应用于一个嵌套的函数的作用域中的一个名称，而不是所有def之外的全局模块作用域，而且在声明nonlocal名称的时候，它必须已经存在于该嵌套函数的作用域中---它们可能只存在于一个嵌套的函数中，并且不能由一个嵌套的def中的第一次赋值创建。


 当执行一条nonlocal语句时，nonlocal名称必须已经在一个嵌套的def作用域中赋值过否则将得到一个错误----不能通过在嵌套的作用域中赋新值来创建它们
其次，nonlocal限制作用域查找仅为嵌套的def，nonlocal不会在嵌套的模块的全局作用域或所有def之外的内置作用域中查找，即便已经有了这些作用域


传递参数：
1，参数的传递是通过自动将对象赋值给本地变量名来实现的
2，在函数内部的参数名的赋值不会影响调用者
3，改变函数的可变对象参数的值也许会对调用者有影响

不可变参数“通过值”进行传递。像整数和字符串这样的对象是通过对象引用而不是拷贝进行传递的。
可变对象是通过“指针”进行传递的。列表和字典这样的可变对象能够在函数内部进行原处的改变

特定的参数匹配模型

func(value)
func(name=value)
func(*sequence)
func(**dict)
def func(name)
def func(name=value)
def func(*name)
def func(**name)
def func(*args,name)
def func(*,name=value)





函数的设计概念
1，耦合性：对于输入使用参数并且对于输出使用return语句
2，耦合性：只有在真正必要的情况下使用全局变量
3，耦合性：不要改变可变类型的参数，除非调用者希望这样做
4，聚合性：每一个函数都应该有一个单一的、统一的目标
5，大小：每一个函数都应该相对较小
6，耦合：避免直接改变在另一个模块文件中的变量



递归函数是可以直接的，也可以是间接的（很可能，递归在内存空间和执行时间方面效率较低)

循环语句VS递归
有了循环语句，我们不需要在调用堆栈上针对每次迭代都有一个本地作用域的副本，但是另一个方面，递归可以要求遍历任意形状的结构。

函数对象不仅有系统定义的属性，用户也可以向函数附加任意的用户定义属性，这样的属性可以用来直接把状态信息加到函数对象，而不必使用全局、非本地和类等其他技术。这样的属性可以在函数自身的任何地方访问。从某种意义上说，这也是模拟其他语言中的“静态本地变量”的一种方式-----这种变量的名称对于一个函数来说是本地的，但是其值在函数退出后仍然保留。

注解annotations只在def语句中有效，在lambda表达式中无效，因为lambda的语法已经限制了它所定义的函数工具

匿名函数lambda
lambda返回了一个函数而不是将这个函数赋值给一个变量名，这也就是lambda有时叫做匿名函数的原因。实际上，它们常常以一种行内进行函数定义的形式使用，或者用作推迟执行一些代码
lambda argument1, argument2,... argumentN :expression using arguments

1，lambda是一个表达式，而不是一个语句。因为这一点，lambda能够出现在Python语法不允许def出现的地方-----例如，在一个列表常量中或者函数调用参数中。此外作为一个表达式，lambda返回了一个值（一个新的函数），可以选择性地赋值给一个变量名。相反，def语句总是得在头部将一个新的函数赋值给一个变量名，而不是将这个函数作为结果返回。
2,lambda的主体是一个单个表达式，而不是一个代码块。lambda通常要比def的功能要小：你仅能够在lambda主体中封装有限的逻辑进去，连if这样的语句都不能够使用。它限制了程序的嵌：lambda是一个为编写简单的函数而设计的，而def用来处理更大的任务。


在lambda主体中的代码像在def内的代码一样都遵循相同的作用域查找法则。lambda表达式引入的一个本地作用域更像一个嵌套的def语句。将会自动从上层函数中、模块中以及内置作用域中（通过LEGB法则）查找变量名

通常来说，lambda起到了一种函数速写的作用，允许在使用的代码内嵌入一个函数的定义。会带来一个更简洁的代码结构。

lambda通常用来编写跳转表（jump table），也就是行为的列表或字典，能够按照需要执行相应的动作。
当需要把小段的可执行代码编写进def语句从语法上不能编写进的地方时，lambda表达式作为def的一种速写是最为有用的。

要在一个lambda中嵌套逻辑，可以使用if/else三元表达式，后者对等的但需要些技巧的and/or组合。
if a:
	b
else:
	c
	<=>
b if a else c
<=>
((a and b) or c)

如果需要在lambda函数中执行循环，能够嵌入map调用或列表解析表达式（python3.0 above）

嵌套lambda和作用域 LEGB原则


map函数会对一个序列对象中的每个元素应用被传入的函数，并且返回一个包含了所有函数调用结果的一个列表。
reduce，filter

列表解析把任意一个表达式而不是一个函数应用于一个迭代对象中的元素。

列表解析是由方括号封装起来的，它们的简单形式是在方括号中编写一个表达式，其中的变量，在后边跟随着的看起来就像1个for循环的头部一样的语句，有着相同的变量名变量。

通用的列表解析结构如下：
[ expression for target1 in iterable1 [ if condition1]
					for target2 in interable2 [ if condition2] ...
					for targetN in interableN [ if conditionN]
]
当for分句嵌套在列表解析中时，它们工作起来就像等效的嵌套的for循环语句

map调用比等效的for循环要快2倍，而列表解析往往比map调用稍微快一些，map和列表解析是在解释器中以C语言的速度来运行的



生成器函数：编写为常规的def语句，但是使用yield语句一次返回一个结果，在每个结果之间挂起和继续它们的状态，当创建时，它们自动实现迭代协议
生成器表达式类似于列表解析，但是，它们返回按需产生的结果的一个对象，而不是构建一个结果列表

可迭代对象定义了一个__next__方法，它要么返回迭代中的下一项，或者引发一个stopIteration异常来终止迭代。一个对象的迭代器用iter内置函数接收。

要支持迭代协议，函数包含一条yield语句，该语句特别编译为生成器。当调用时，它们返回一个迭代器对象，该对象支持用一个名为__next__的自动创建的方法来继续执行接口。生成器函数也可能有一条return语句，总是在def语句块的末尾，直接终止值的生成。

生成器在内存使用和性能方面都很好。它们允许函数避免临时再做所有的工作，当结果的列表很大或者在处理每一个结果都需要很长时间时，这一点尤其有用。
扩展生成器函数协议：send和next

生成器表达式：迭代器遇到列表解析
从语法上来讲，生成器的表达式就像一般的列表解析一样，但是它们是括在圆括号中的而不是方括号中的。

实际上，至少在一个函数的基础上，编写一个列表解析基本上等同于：在一个list内置调用中包含一个生成器表达式以迫使其一次生成列表中所有的结果。尽管如此，从执行过程上来讲，生成器表达式很不相同：不是在内存中构建结果，而是返回一个生成器对象，这个对象将会支持迭代协议并在任意的迭代语境的操作中。
我们一般不会机械地使用next迭代器来操作生成器表达式，因为for循环会自动触发。
生成器表达式大体上可以认为是对内存空间的优化，它们不需要像方括号列表解析一样，一次构造出整个结果列表。它们在实际中运行起来可能稍慢一些，所以它们对于非常大的结果集合的运算是最优选择。


生成器函数VS生成器表达式，这两种都支持自动和手动迭代
生成器是单迭代对象

函数陷阱
1，Python是静态检测Python的本地变量的，当编译def代码时，不是通过发现赋值语句在运行时进行检测的。实际上，任何在函数体内的赋值将会使其成为一个本地变量名。Import、=、嵌套def、嵌套类等，都会受到这种行为的影响。
2，默认和可变对象，默认参数是在def语句运行时评估并保存的，而不是在这个函数调用时。从内部来讲，Python会将每一个默认参数保存成一个对象，附加在这个函数本身。
3，没有return语句的函数，在Python函数中，return以及yield语句时可选的。当一个函数没有精确的返回值的时候，函数在控制权从函数主体脱离时，函数会退出。如果没有return语句，函数自动返回None对象。
4，嵌套作用域的循环变量



模块是最高级别的程序组织单元，它将程序代码和数据封装起来以便重用。
import from imp.reload
模块的三个角色：
1，代码重用
2，系统命名空间的划分
3，实现共享服务和数据

程序第一次导入指定文件时，会执行三个步骤：
1，找到模块文件
2，编译成位码（需要时）
3，执行模块的代码来创建其所定义的对象



































