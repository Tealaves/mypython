一个在def内定义的变量名能够被def内的代码使用。不能在函数的外部引用这样的变量名
def之中的变量名与def之外的变量名并不冲突，即使是使用在别处相同的变量名。一个在def之外被赋值的变量X与在这个def之中的赋值变量x是完全不同的变量

函数定义了本地作用域，而模块定义的是全局作用域。这两个作用域的关系如下：
1，内嵌的模块是全局作用域
2，全局作用域的作用范围仅限于单个文件
3，每次对函数的调用都创建了一个新的本地作用域（递归在处理不能提前预知的流程结构时是一个有用的工具）
4，赋值的变量名除非声明为全局变量或非本地变量，否则均为本地变量
5，所有其他的变量名都可以归纳为本地、全局或者内置的
修改一个对象并不是对一个名称赋值

变量名解析：
a>变量名引用分为三个作用域进行查找：首先是本地，之后是函数内（如果有的话），之后全局，最后是内置
b>默认情况下，变量名赋值会创建或者改变本地变量。
c>全局声明和非本地声明将赋值的变量名映射到模块文件内部的作用域

内置作用域仅仅是一个名为_builtin_的内置模块，但是必须要import_buildin_之后才能使用内置作用域，因为变量名builtin本身并没有预先内置

global是一个命名空间的声明，它告诉Python函数打算生成一个或多个全局变量名。

全局变量名总结：
1，全局变量是位于模块文件内部的顶层的变量名
2，全局变量如果是在函数内被赋值的话，必须经过声明
3，全局变量名在函数的内部不经过声明也可以被引用

在文件间进行通信的最好办法就是通过调用函数，传递函数，然后得到其返回值。

工厂函数，一个能够记住嵌套作用域的变量值的函数，尽管那个作用域已经不存在了。
 
 如果lambda或者def在函数中定义，嵌套在一个循环之中，并且嵌套的函数引用了一个上层作用域变量，该变量被循环所改变，所有在这个循环中产生的函数将会有相同的值--在最后一次循环中完成时被引用的变量的值

 nonlocal和global一样，声明了将要在一个嵌套的作用域中修改的名称。和global的不同之处在于，nonlocal应用于一个嵌套的函数的作用域中的一个名称，而不是所有def之外的全局模块作用域，而且在声明nonlocal名称的时候，它必须已经存在于该嵌套函数的作用域中---它们可能只存在于一个嵌套的函数中，并且不能由一个嵌套的def中的第一次赋值创建。


 当执行一条nonlocal语句时，nonlocal名称必须已经在一个嵌套的def作用域中赋值过否则将得到一个错误----不能通过在嵌套的作用域中赋新值来创建它们
其次，nonlocal限制作用域查找仅为嵌套的def，nonlocal不会在嵌套的模块的全局作用域或所有def之外的内置作用域中查找，即便已经有了这些作用域


传递参数：
1，参数的传递是通过自动将对象赋值给本地变量名来实现的
2，在函数内部的参数名的赋值不会影响调用者
3，改变函数的可变对象参数的值也许会对调用者有影响

不可变参数“通过值”进行传递。像整数和字符串这样的对象是通过对象引用而不是拷贝进行传递的。
可变对象是通过“指针”进行传递的。列表和字典这样的可变对象能够在函数内部进行原处的改变

特定的参数匹配模型

func(value)
func(name=value)
func(*sequence)
func(**dict)
def func(name)
def func(name=value)
def func(*name)
def func(**name)
def func(*args,name)
def func(*,name=value)





函数的设计概念
1，耦合性：对于输入使用参数并且对于输出使用return语句
2，耦合性：只有在真正必要的情况下使用全局变量
3，耦合性：不要改变可变类型的参数，除非调用者希望这样做
4，聚合性：每一个函数都应该有一个单一的、统一的目标
5，大小：每一个函数都应该相对较小
6，耦合：避免直接改变在另一个模块文件中的变量



递归函数是可以直接的，也可以是间接的（很可能，递归在内存空间和执行时间方面效率较低)

循环语句VS递归
有了循环语句，我们不需要在调用堆栈上针对每次迭代都有一个本地作用域的副本，但是另一个方面，递归可以要求遍历任意形状的结构。

函数对象不仅有系统定义的属性，用户也可以向函数附加任意的用户定义属性，这样的属性可以用来直接把状态信息加到函数对象，而不必使用全局、非本地和类等其他技术。这样的属性可以在函数自身的任何地方访问。从某种意义上说，这也是模拟其他语言中的“静态本地变量”的一种方式-----这种变量的名称对于一个函数来说是本地的，但是其值在函数退出后仍然保留。

注解annotations只在def语句中有效，在lambda表达式中无效，因为lambda的语法已经限制了它所定义的函数工具

匿名函数lambda
lambda返回了一个函数而不是将这个函数赋值给一个变量名，这也就是lambda有时叫做匿名函数的原因。实际上，它们常常以一种行内进行函数定义的形式使用，或者用作推迟执行一些代码
lambda argument1, argument2,... argumentN :expression using arguments

1，lambda是一个表达式，而不是一个语句。因为这一点，lambda能够出现在Python语法不允许def出现的地方-----例如，在一个列表常量中或者函数调用参数中。此外作为一个表达式，lambda返回了一个值（一个新的函数），可以选择性地赋值给一个变量名。相反，def语句总是得在头部将一个新的函数赋值给一个变量名，而不是将这个函数作为结果返回。
2,lambda的主体是一个单个表达式，而不是一个代码块。lambda通常要比def的功能要小：你仅能够在lambda主体中封装有限的逻辑进去，连if这样的语句都不能够使用。它限制了程序的嵌：lambda是一个为编写简单的函数而设计的，而def用来处理更大的任务。


在lambda主体中的代码像在def内的代码一样都遵循相同的作用域查找法则。lambda表达式引入的一个本地作用域更像一个嵌套的def语句。将会自动从上层函数中、模块中以及内置作用域中（通过LEGB法则）查找变量名

通常来说，lambda起到了一种函数速写的作用，允许在使用的代码内嵌入一个函数的定义。会带来一个更简洁的代码结构。

lambda通常用来编写跳转表（jump table），也就是行为的列表或字典，能够按照需要执行相应的动作。
当需要把小段的可执行代码编写进def语句从语法上不能编写进的地方时，lambda表达式作为def的一种速写是最为有用的。

要在一个lambda中嵌套逻辑，可以使用if/else三元表达式，后者对等的但需要些技巧的and/or组合。
if a:
	b
else:
	c
	<=>
b if a else c
<=>
((a and b) or c)

如果需要在lambda函数中执行循环，能够嵌入map调用或列表解析表达式（python3.0 above）

嵌套lambda和作用域 LEGB原则


map函数会对一个序列对象中的每个元素应用被传入的函数，并且返回一个包含了所有函数调用结果的一个列表。
reduce，filter

列表解析把任意一个表达式而不是一个函数应用于一个迭代对象中的元素。

列表解析是由方括号封装起来的，它们的简单形式是在方括号中编写一个表达式，其中的变量，在后边跟随着的看起来就像1个for循环的头部一样的语句，有着相同的变量名变量。

通用的列表解析结构如下：
[ expression for target1 in iterable1 [ if condition1]
					for target2 in interable2 [ if condition2] ...
					for targetN in interableN [ if conditionN]
]
当for分句嵌套在列表解析中时，它们工作起来就像等效的嵌套的for循环语句

map调用比等效的for循环要快2倍，而列表解析往往比map调用稍微快一些，map和列表解析是在解释器中以C语言的速度来运行的



生成器函数：编写为常规的def语句，但是使用yield语句一次返回一个结果，在每个结果之间挂起和继续它们的状态，当创建时，它们自动实现迭代协议
生成器表达式类似于列表解析，但是，它们返回按需产生的结果的一个对象，而不是构建一个结果列表

可迭代对象定义了一个__next__方法，它要么返回迭代中的下一项，或者引发一个stopIteration异常来终止迭代。一个对象的迭代器用iter内置函数接收。

要支持迭代协议，函数包含一条yield语句，该语句特别编译为生成器。当调用时，它们返回一个迭代器对象，该对象支持用一个名为__next__的自动创建的方法来继续执行接口。生成器函数也可能有一条return语句，总是在def语句块的末尾，直接终止值的生成。

生成器在内存使用和性能方面都很好。它们允许函数避免临时再做所有的工作，当结果的列表很大或者在处理每一个结果都需要很长时间时，这一点尤其有用。
扩展生成器函数协议：send和next

生成器表达式：迭代器遇到列表解析
从语法上来讲，生成器的表达式就像一般的列表解析一样，但是它们是括在圆括号中的而不是方括号中的。

实际上，至少在一个函数的基础上，编写一个列表解析基本上等同于：在一个list内置调用中包含一个生成器表达式以迫使其一次生成列表中所有的结果。尽管如此，从执行过程上来讲，生成器表达式很不相同：不是在内存中构建结果，而是返回一个生成器对象，这个对象将会支持迭代协议并在任意的迭代语境的操作中。
我们一般不会机械地使用next迭代器来操作生成器表达式，因为for循环会自动触发。
生成器表达式大体上可以认为是对内存空间的优化，它们不需要像方括号列表解析一样，一次构造出整个结果列表。它们在实际中运行起来可能稍慢一些，所以它们对于非常大的结果集合的运算是最优选择。


生成器函数VS生成器表达式，这两种都支持自动和手动迭代
生成器是单迭代对象

函数陷阱
1，Python是静态检测Python的本地变量的，当编译def代码时，不是通过发现赋值语句在运行时进行检测的。实际上，任何在函数体内的赋值将会使其成为一个本地变量名。Import、=、嵌套def、嵌套类等，都会受到这种行为的影响。
2，默认和可变对象，默认参数是在def语句运行时评估并保存的，而不是在这个函数调用时。从内部来讲，Python会将每一个默认参数保存成一个对象，附加在这个函数本身。
3，没有return语句的函数，在Python函数中，return以及yield语句时可选的。当一个函数没有精确的返回值的时候，函数在控制权从函数主体脱离时，函数会退出。如果没有return语句，函数自动返回None对象。
4，嵌套作用域的循环变量



模块是最高级别的程序组织单元，它将程序代码和数据封装起来以便重用。
import from imp.reload
模块的三个角色：
1，代码重用
2，系统命名空间的划分
3，实现共享服务和数据

程序第一次导入指定文件时，会执行三个步骤：
1，找到模块文件
2，编译成位码（需要时）
3，执行模块的代码来创建其所定义的对象



import和from都是赋值语句
1，import将整个模块对象赋值给一个变量名
2，from将一个或多个变量名赋值给另一个模块中同名的对象


from只是把变量名从一个模块复制到另一个模块，并不会对模块名本身进行赋值。就像所有的赋值语句一样，from语句会在导入者中创建新的变量，而那些变量初始化时引用了导入文件中的同名对象。不过，只有变量名被复制出来，而非模块本身。当我们使用语句from *这种形式时，等效的写法是一样的，只不过是模块中所有的顶层变量名都会以这种方式复制到进行导入的作用域中。

from语句潜在的陷阱，from和reload调用同时使用时，from语句有比较严重的问题，因为导入的变量名可能引用之前版本的对象。再者，from module import *形式的确可能破坏命名空间，让变量难以理解，尤其是在导入一个以上的文件时。
简单模块一般倾向于使用import，而不是from。多数的from语句是用于明确列举出想要的变量，而且限制在每个文件中只用一次from *形式。

模块最好理解为变量名的封装。

1，模块语句会在首次导入时执行。系统中，模块在第一次导入时无论在什么地方，Python都会简历空的模块对象，并逐一执行该模块文件内的语句，依照文件从头到尾的顺序。
2，顶层的赋值语句会创建模块属性。在导入时，文件顶层（不在def或class之内）赋值变量的语句，会建立模块对象的属性，赋值的变量名会存储在模块的命名空间内。



有种特殊的情况，把下划线放在变量名前面（例如，_X），可以防止客户端使from *语句导入模块名时，把其中的那些变量名复制出去。这其实是对命名空间的破坏最小而已。因为from *会把所有变量名复制出去，导入者可能得到超出它所需的部分。下划线不是私有声明：你还可以使用其他导入形式看见并修改这类变量名。
此外，也可以在模块顶层把变量名的字符串列表赋值给变量__all__，以达到类似于_X命名惯例的隐藏效果。例如：
__all__ = ["Error", "encode", "decode"]
Python会先寻早模块内的__all__列表，如果没有定义的话，from *就会复制出开头没有单下划线的所有变量名

混合用法模式：__name__和__main__
每个模块文件都有个名为__name__的内置属性，Python会自动设置该属性
1，如果文件是以顶层程序文件执行，在启动时，__name__就会设置为字符串"__main__"
2，如果文件被导入，__name__就会改设成客户端所了解的模块名
结果就是模块可以检测自己的__name__，来确定它是在执行还是在导入

实际上，一个模块的__name__变量充当一个使用模式标志，允许它编写成一个可导入的库和一个顶层脚本。也许使用__name__测试是最常见的自我测试代码。简而言之，可以在文件末尾加个__name__测试，把测试模块导出的程序代码放在模块中。unittest和doctest标准库模块，提供更为高级的测试工具

import语句和from语句的as扩展
import modulename as name   <=> 
import modulename
name = modulename
del modulname

from modulename import attrname as name

import reallylongmodulename as name
name.func()

from module1 import utility as util1
from module2 import utility as util2
util1(), util(2)

import dir1.dir2.mod as mod
mod.func()

因为模块通过内置属性显示了它们大多数有趣的特性，因此，可很容易地编写程序来管理其他程序。我们通常称这类管理程序为元程序(metaprogram),因为它们是在系统之上工作。这也称为内省(introspection)


 用名称字符串导入模块：
 
一条import或from语句中的模块名是直接编写的变量名称。从运行时生成的一个字符串来动态地载入一个模块。最通用的方法是，把一条导入语句构建为Python代码的一个字符串，并且将其传递给exec内置函数以运行。
modulename = "string"
exec("import" + modulename)
string


exec函数（及其近亲eval）编译一个代码字符串，并且将其传递给Python解释器以执行。在Python中，字节代码编译器在运行时可以使用，默认情况下，exec运行当前作用域中的代码，但是，你可以通过传入可选的命名空间字典来更加具体地应用

如果使用内置的__import__函数从一个名称字符串载入的话，代码可能会运行的更快
modname = "string"
string = __import__(modname)
string
































