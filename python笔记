一个在def内定义的变量名能够被def内的代码使用。不能在函数的外部引用这样的变量名
def之中的变量名与def之外的变量名并不冲突，即使是使用在别处相同的变量名。一个在def之外被赋值的变量X与在这个def之中的赋值变量x是完全不同的变量

函数定义了本地作用域，而模块定义的是全局作用域。这两个作用域的关系如下：
1，内嵌的模块是全局作用域
2，全局作用域的作用范围仅限于单个文件
3，每次对函数的调用都创建了一个新的本地作用域（递归在处理不能提前预知的流程结构时是一个有用的工具）
4，赋值的变量名除非声明为全局变量或非本地变量，否则均为本地变量
5，所有其他的变量名都可以归纳为本地、全局或者内置的
修改一个对象并不是对一个名称赋值

变量名解析：
a>变量名引用分为三个作用域进行查找：首先是本地，之后是函数内（如果有的话），之后全局，最后是内置
b>默认情况下，变量名赋值会创建或者改变本地变量。
c>全局声明和非本地声明将赋值的变量名映射到模块文件内部的作用域

内置作用域仅仅是一个名为_builtin_的内置模块，但是必须要import_buildin_之后才能使用内置作用域，因为变量名builtin本身并没有预先内置

global是一个命名空间的声明，它告诉Python函数打算生成一个或多个全局变量名。

全局变量名总结：
1，全局变量是位于模块文件内部的顶层的变量名
2，全局变量如果是在函数内被赋值的话，必须经过声明
3，全局变量名在函数的内部不经过声明也可以被引用

在文件间进行通信的最好办法就是通过调用函数，传递函数，然后得到其返回值。

工厂函数，一个能够记住嵌套作用域的变量值的函数，尽管那个作用域已经不存在了。
 
 如果lambda或者def在函数中定义，嵌套在一个循环之中，并且嵌套的函数引用了一个上层作用域变量，该变量被循环所改变，所有在这个循环中产生的函数将会有相同的值--在最后一次循环中完成时被引用的变量的值

 nonlocal和global一样，声明了将要在一个嵌套的作用域中修改的名称。和global的不同之处在于，nonlocal应用于一个嵌套的函数的作用域中的一个名称，而不是所有def之外的全局模块作用域，而且在声明nonlocal名称的时候，它必须已经存在于该嵌套函数的作用域中---它们可能只存在于一个嵌套的函数中，并且不能由一个嵌套的def中的第一次赋值创建。


 当执行一条nonlocal语句时，nonlocal名称必须已经在一个嵌套的def作用域中赋值过否则将得到一个错误----不能通过在嵌套的作用域中赋新值来创建它们
其次，nonlocal限制作用域查找仅为嵌套的def，nonlocal不会在嵌套的模块的全局作用域或所有def之外的内置作用域中查找，即便已经有了这些作用域


传递参数：
1，参数的传递是通过自动将对象赋值给本地变量名来实现的
2，在函数内部的参数名的赋值不会影响调用者
3，改变函数的可变对象参数的值也许会对调用者有影响

不可变参数“通过值”进行传递。像整数和字符串这样的对象是通过对象引用而不是拷贝进行传递的。
可变对象是通过“指针”进行传递的。列表和字典这样的可变对象能够在函数内部进行原处的改变

特定的参数匹配模型

func(value)
func(name=value)
func(*sequence)
func(**dict)
def func(name)
def func(name=value)
def func(*name)
def func(**name)
def func(*args,name)
def func(*,name=value)




































